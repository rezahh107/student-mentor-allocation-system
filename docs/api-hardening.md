# API Hardening Overview

این مستند خلاصه‌ای از سیاست‌های امنیتی، تکرارناپذیری و پایش‌پذیری سرویس سخت‌سازی‌شدهٔ تخصیص دانش‌آموز است.

## احراز هویت و کنترل دسترسی

- استفاده از یکی از دو هدر `Authorization: Bearer <token>` یا `X-API-Key` الزامی است.
- رشتهٔ ورودی باید الگوی ASCII `^[A-Za-z0-9._-]{16,128}$` را رعایت کند.
- JWT ها صرفاً با الگوریتم HS256 پذیرفته می‌شوند و `aud/iss` باید در لیست مجاز باشد؛ تلرانس زمانی ۱۲۰ ثانیه اعمال می‌شود.
- فیلد `jti` در Redis ذخیره و برای ابطال توکن‌ها بررسی می‌شود.
- کلیدهای API با HMAC-SHA256 و نمک اختصاصی هش و در جدول `api_keys` ذخیره می‌شوند. ستون‌های `expires_at` و `revoked_at` برای مدیریت چرخهٔ عمر افزوده شده‌اند و توسط CLI (`tools/api_keys.py`) قابل مشاهده/صدور/ابطال هستند.

## لایهٔ پایداری (Redis)

- تمام حالت‌های حساس (تکرارناپذیری، محدودیت نرخ، JWT deny-list) در Redis و با namespace‌ مشتق‌شده از محیط ذخیره می‌شوند.
- TTL پیش‌فرض کلید تکرارناپذیری ۲۴ ساعت است. پاسخ موفق اولیه به صورت JSON ذخیره شده و رونوشت‌های بعدی بدون تماس با سرویس تراکنشی بازگردانده می‌شود.
- رزرو تکرارناپذیری با عملیات `SETNX` اتمیک و backoff نمایی + jitter انجام می‌شود تا در سناریوهای همزمانی فقط یک فراخوانی به `allocation_tx` انجام شود؛ خطاهای Redis بر اساس تنظیمات `REDIS_MAX_RETRIES`، `REDIS_BASE_DELAY_MS`، `REDIS_MAX_DELAY_MS` و `REDIS_JITTER_MS` با تأخیر افزایشی تکرار می‌شوند.
- سیاست Fail-Open برای محدودیت نرخ قابل پیکربندی است؛ GET ها در حالت خطا به صورت Fail-Open عبور داده می‌شوند اما `POST /allocations` در حالت پیش‌فرض Fail-Closed باقی می‌ماند.
- مقادیر محیطی بالا به همراه `REDIS_NAMESPACE` در README و CLI مستند شده و به کمک آن‌ها می‌توان رفتار Retry را در محیط‌های مختلف تنظیم کرد.
- لانچر Redis در آزمون‌های محلی ابتدا تلاش می‌کند باینری `redis-server` را اجرا کند و در صورت نبود آن به صورت خودکار کانتینر `redis:7` را با Docker بالا می‌آورد؛ حالت انتخاب‌شده در لاگ با فیلد `redis_launch_mode` ثبت می‌شود و می‌توان با `REDIS_LAUNCH_MODE=skip` محیط‌های فاقد Docker را به صورت کنترل‌شده xfail کرد.

## محدودیت نرخ

| مسیر | حد مجاز | بازه |
|------|---------|-------|
| `POST /allocations` | ۵ درخواست | ۱ ثانیه |
| `GET /status` | ۲۰ درخواست | ۱ ثانیه |

- الگوریتم Sliding-Window بر مبنای Sorted-Set های Redis پیاده‌سازی شده و در صورت بروز خطا با همان سیاست Retry و پارامترهای قابل تنظیم، متریک و لاگ مخصوص (مشروح در بخش مشاهده‌پذیری) تولید می‌کند؛ GET ها در صورت خطا Fail-Open خواهند شد.
- در صورت عبور از حد مجاز، پاسخ 429 با بدنهٔ فارسی و کد `RATE_LIMIT_EXCEEDED` همراه با هدرهای `Retry-After` و `X-RateLimit-Remaining` بازگردانده می‌شود.
- آزمون‌های همزمانی ۲۰ درخواست موازی را پوشش داده و تضمین می‌کنند تنها یک تخصیص واقعی انجام شود.

## کلید تکرارناپذیری

- هدر `Idempotency-Key` در صورت ارسال باید ASCII با طول ۱۶ تا ۱۲۸ کاراکتر باشد.
- بدنهٔ درخواست با نمک داخلی هش شده و در Redis ذخیره می‌شود؛ عدم تطابق هش خطای `409 CONFLICT` تولید می‌کند.
- سناریوهای آلودگی (کلیدهای منقضی‌شده/نیمه‌کاره) در آزمون‌ها پاکسازی شده و به صورت خودکار منجر به اجرای مجدد امن می‌شود.

## اعتبارسنجی داده‌ها

- محتوا باید دقیقاً `application/json; charset=utf-8` باشد و حجم بدنه از ۳۲ کیلوبایت تجاوز نکند.
- مقادیر `reg_center ∈ {0,1,2}`، `reg_status ∈ {0,1,3}` و `gender ∈ {0,1}` هستند.
- ورودی‌ها نرمال‌سازی NFKC، یکسان‌سازی «ی/ك» و حذف کاراکترهای صفرعرض را تجربه می‌کنند؛ ارقام فارسی/عربی به لاتین تبدیل می‌شوند.
- خطاها در پاکت استاندارد زیر بازگردانده می‌شوند:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message_fa": "اطلاعات ارسال‌شده نامعتبر است",
    "correlation_id": "...",
    "details": [...]
  }
}
```

## مشاهده‌پذیری

- لاگ‌ها به صورت JSON و دارای فیلدهای `ts`, `level`, `msg`, `correlation_id`, `request_id`, `consumer_id`, `path`, `method`, `status`, `latency_ms`, `outcome`, `error_code` هستند. داده‌های حساس مانند کدملی و تلفن قبل از ثبت، هش/ماسک می‌شوند.
- شاخص‌های Prometheus شامل `http_requests_total`, `http_request_duration_seconds`, `http_requests_in_flight`, `auth_fail_total`, `rate_limit_reject_total`, `alloc_attempt_total`, `redis_retry_attempts_total`, `redis_retry_exhausted_total`, `redis_operation_latency_seconds` بوده و مسیر `/metrics` با توکن یا IP مجاز حفاظت می‌شود.
- در صورت اتمام Retry های Redis، رویداد `redis.retry_exhausted` با فیلدهای `rid`, `op`, `attempts`, `namespace`، `last_error` در خروجی JSON ثبت و متریک‌های مرتبط افزایش می‌یابند تا ریشه‌یابی خطا تسهیل شود.
- قلاب‌های OpenTelemetry برای رهگیری توزیع‌شده با شناسهٔ همبستگی فعال هستند.

## سربار هدرها و امنیت شبکه

- `X-Request-ID` اگر ارائه شود به عنوان `correlation_id` استفاده می‌شود؛ در غیر این صورت UUIDv4 تولید شده و در هدر پاسخ `X-Correlation-ID` بازتاب داده می‌شود.
- هدرهای امنیتی `X-Content-Type-Options=nosniff`، `X-Frame-Options=DENY`، `Referrer-Policy=no-referrer` و سیاست CORS با فهرست سفید سخت‌گیرانه اعمال می‌شوند.
- مسیر `/metrics` تنها برای IP های مجاز یا با توکن مخفی قابل دسترس است.

## پوشش آزمون‌ها

- ورودی‌های تهی، صفر، رشته‌های خالی و ترکیب ارقام فارسی/عربی.
- بدنه‌های بزرگ‌تر از ۳۲ کیلوبایت و محتوای با `Content-Type` اشتباه.
- احراز هویت ناقص (توکن مفقود، امضا/انقضا/سطح دسترسی نامعتبر، کلید API منقضی یا ابطال‌شده).
- سناریوهای همزمانی: ۲۰ درخواست موازی با کلید یکسان و اطمینان از اجرای تنها یک تراکنش.
- حالت‌های آلودگی Redis (bucket های قدیمی محدودیت نرخ، کلیدهای تکرارناپذیری منقضی) و پاکسازی خودکار.
- ارزیابی عملکردی p95 برای GET و POST در CI با درنظرگرفتن هزینهٔ پاکسازی و Retry.
- خروجی‌های اکسل در زنجیرهٔ فاز شش با نقل‌قول اجباری و خنثی‌سازی فرمول از طریق تست‌های طلایی بررسی می‌شوند.
- رجیستری Prometheus پیش و پس از هر آزمون با نگهبان اختصاصی پاک‌سازی می‌شود تا نمونه‌ها و برچسب‌های قدیمی به سناریوهای بعدی نشت نکنند؛ آزمون‌های `observability` پاک بودن رجیستری را تضمین می‌کنند.
- هر تغییری در پیکربندی محدودیت نرخ باید داخل نگهبان `temporary_rate_limit_config` انجام شود؛ در غیر این صورت آزمون‌ها با پیام شفاف شکست می‌خورند تا عدم بازگردانی پیکربندی آشکار شود.
- مقدار `asyncio_mode=auto` در `pytest.ini` ثبت شده و پلاگین سازگاری (`tests._compat.pytest_asyncio_scope`) پیش از شروع آزمون‌ها آن را enforce می‌کند؛ بنابراین اجرای `pytest` بدون پرچم اضافی `-o` فاقد اخطارهای Pytest-Asyncio خواهد بود.
- کلاینت‌های HTTP مبتنی بر `httpx.AsyncClient` + `ASGITransport` هستند و به جای `data=` خام از `json=` یا `content=` استفاده می‌کنند تا اخطارهای فرسودگی HTTPX حذف و سازگاری آتی حفظ شود.
