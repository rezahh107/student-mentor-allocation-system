"""High level audit service orchestrating validation and metrics."""
from __future__ import annotations

import logging
import re
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncIterator
from zoneinfo import ZoneInfo

from prometheus_client import CollectorRegistry, Counter

from src.reliability.clock import Clock

from .enums import AuditAction, AuditActorRole, AuditOutcome
from .repository import AuditEventCreate, AuditQuery, AuditRepository

_LOGGER = logging.getLogger("audit.service")
_REQUEST_ID_RE = re.compile(r"^(?:[0-9a-fA-F]{32,64}|[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$")
_DEFAULT_TZ = ZoneInfo("Asia/Tehran")


@dataclass(slots=True)
class AuditEventRecord:
    id: int
    ts: datetime
    actor_role: AuditActorRole
    center_scope: str | None
    action: AuditAction
    resource_type: str
    resource_id: str
    job_id: str | None
    request_id: str
    outcome: AuditOutcome
    error_code: str | None
    artifact_sha256: str | None


@dataclass(slots=True)
class AuditMetrics:
    """Prometheus counters bundled with the backing registry."""

    registry: CollectorRegistry
    events_total: Counter
    export_bytes_total: Counter
    review_runs_total: Counter
    archive_runs_total: Counter
    archive_bytes_total: Counter
    archive_fail_total: Counter
    retention_purges_total: Counter
    retry_attempts_total: Counter
    retry_exhausted_total: Counter


def build_metrics(*, registry: CollectorRegistry | None = None) -> AuditMetrics:
    registry = registry or CollectorRegistry()
    events_total = Counter(
        "audit_events_total",
        "Total number of audit events recorded",
        labelnames=("action", "outcome"),
        registry=registry,
    )
    export_bytes_total = Counter(
        "audit_export_bytes_total",
        "Total bytes generated by audit exports",
        labelnames=("format",),
        registry=registry,
    )
    review_runs_total = Counter(
        "audit_review_runs_total",
        "Count of access review report runs",
        labelnames=("status",),
        registry=registry,
    )
    archive_runs_total = Counter(
        "audit_archive_runs_total",
        "Total archiver executions grouped by status.",
        labelnames=("status", "month"),
        registry=registry,
    )
    archive_bytes_total = Counter(
        "audit_archive_bytes_total",
        "Bytes emitted by audit archiver per artifact type.",
        labelnames=("type",),
        registry=registry,
    )
    archive_fail_total = Counter(
        "audit_archive_fail_total",
        "Failures during audit archiver stages.",
        labelnames=("stage",),
        registry=registry,
    )
    retention_purges_total = Counter(
        "audit_retention_purges_total",
        "Count of partitions purged by retention enforcer.",
        labelnames=("reason",),
        registry=registry,
    )
    retry_attempts_total = Counter(
        "audit_retry_attempts_total",
        "Total retry attempts triggered by audit lifecycle operations.",
        labelnames=("stage",),
        registry=registry,
    )
    retry_exhausted_total = Counter(
        "audit_retry_exhausted_total",
        "Count of audit lifecycle operations exhausting all retry attempts.",
        labelnames=("stage",),
        registry=registry,
    )
    return AuditMetrics(
        registry=registry,
        events_total=events_total,
        export_bytes_total=export_bytes_total,
        review_runs_total=review_runs_total,
        archive_runs_total=archive_runs_total,
        archive_bytes_total=archive_bytes_total,
        archive_fail_total=archive_fail_total,
        retention_purges_total=retention_purges_total,
        retry_attempts_total=retry_attempts_total,
        retry_exhausted_total=retry_exhausted_total,
    )


class AuditService:
    """Primary entry point used by API/UI hooks."""

    def __init__(
        self,
        repository: AuditRepository,
        clock: Clock,
        *,
        metrics: AuditMetrics,
        timezone: ZoneInfo = _DEFAULT_TZ,
    ) -> None:
        self._repository = repository
        self._clock = clock
        self._timezone = timezone
        self._metrics = metrics

    @property
    def metrics_registry(self) -> CollectorRegistry:
        """Expose the registry for `/metrics` scraping endpoints."""

        return self._metrics.registry

    @property
    def timezone(self) -> ZoneInfo:
        return self._timezone

    def now(self) -> datetime:
        return self._clock.now().astimezone(self._timezone)

    async def record_event(
        self,
        *,
        actor_role: AuditActorRole,
        center_scope: str | None,
        action: AuditAction,
        resource_type: str,
        resource_id: str,
        request_id: str,
        outcome: AuditOutcome,
        job_id: str | None = None,
        error_code: str | None = None,
        artifact_sha256: str | None = None,
    ) -> int:
        self._validate_identifier(resource_type)
        self._validate_identifier(resource_id)
        if center_scope is not None:
            self._validate_center(center_scope)
        self._validate_request_id(request_id)
        ts = self._clock.now().astimezone(self._timezone)
        payload = AuditEventCreate(
            ts=ts,
            actor_role=actor_role,
            center_scope=center_scope or None,
            action=action,
            resource_type=self._normalize(resource_type),
            resource_id=self._normalize(resource_id),
            job_id=self._normalize(job_id) if job_id else None,
            request_id=request_id,
            outcome=outcome,
            error_code=self._normalize(error_code) if error_code else None,
            artifact_sha256=self._normalize(artifact_sha256) if artifact_sha256 else None,
        )
        rid = request_id
        event_id = await self._repository.insert(payload, rid=rid)
        self._metrics.events_total.labels(action=action.value, outcome=outcome.value).inc()
        _LOGGER.info(
            "AUDIT_EVENT_RECORDED",
            extra={
                "rid": rid,
                "action": action.value,
                "outcome": outcome.value,
                "resource": resource_type,
            },
        )
        return event_id

    async def list_events(self, query: AuditQuery) -> list[AuditEventRecord]:
        events = await self._repository.fetch_many(query)
        return [self._to_record(event) for event in events]

    async def get_event(self, event_id: int) -> AuditEventRecord | None:
        event = await self._repository.fetch_one(event_id)
        if event is None:
            return None
        return self._to_record(event)

    async def stream_events(self, query: AuditQuery) -> AsyncIterator[AuditEventRecord]:
        async for event in self._repository.stream(query):
            yield self._to_record(event)


    def record_review_run(self, status: str) -> None:
        self._metrics.review_runs_total.labels(status=status).inc()

    def log_failure(self, *, rid: str, op: str, namespace: str, error: Exception) -> None:
        _LOGGER.error(
            "AUDIT_FAILURE",
            extra={
                "rid": rid,
                "op": op,
                "namespace": namespace,
                "last_error": repr(error),
            },
        )

    def _to_record(self, event) -> AuditEventRecord:
        return AuditEventRecord(
            id=event.id,
            ts=event.ts,
            actor_role=event.actor_role,
            center_scope=event.center_scope,
            action=event.action,
            resource_type=event.resource_type,
            resource_id=event.resource_id,
            job_id=event.job_id,
            request_id=event.request_id,
            outcome=event.outcome,
            error_code=event.error_code,
            artifact_sha256=event.artifact_sha256,
        )

    @staticmethod
    def _normalize(value: str | None) -> str:
        if value is None:
            return ""
        sanitized = value.strip().replace("\u200c", "")
        return sanitized[:256]

    @staticmethod
    def _validate_identifier(value: str) -> None:
        if not value or len(value.strip()) == 0:
            raise ValueError("AUDIT_VALIDATION_ERROR: مقدار شناسه نامعتبر است")

    @staticmethod
    def _validate_center(value: str) -> None:
        if len(value) > 64:
            raise ValueError("AUDIT_VALIDATION_ERROR: شناسه مرکز بیش از حد طولانی است")

    @staticmethod
    def _validate_request_id(value: str) -> None:
        if not _REQUEST_ID_RE.match(value):
            raise ValueError("AUDIT_VALIDATION_ERROR: شناسه ردیابی نامعتبر است")


__all__ = ["AuditService", "AuditMetrics", "build_metrics", "AuditEventRecord"]
