name: CI (Redis + RedisTLS for integration)

on:
  workflow_dispatch: {}
  push:
    branches: ["ci/redis-tls-services"]
  pull_request:
    branches: ["main"]

jobs:
  ci-redis-tls:
    runs-on: ubuntu-latest

    env:
      TZ: Asia/Tehran
      PYTEST_DISABLE_PLUGIN_AUTOLOAD: "1"
      PYTHONWARNINGS: error
      REDIS_URL:  redis://127.0.0.1:6379/15
      REDISS_URL: rediss://127.0.0.1:6380/15
      REDIS_TLS_CA_FILE: /tmp/certs/server.crt
      # برای سناریوی منفی allow_insecure در تست‌ها:
      REDIS_TLS_ALLOW_INSECURE: "1"

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # --- Generate deterministic-enough TLS materials (no repo secrets) ---
      - name: Generate TLS certificates
        run: |
          set -euo pipefail
          mkdir -p /tmp/certs
          # Self-signed CA/server (CN=localhost). تاریخ مهم تست‌ها نیست.
          openssl req -x509 -nodes -newkey rsa:2048 \
            -keyout /tmp/certs/server.key \
            -out    /tmp/certs/server.crt \
            -subj "/C=US/ST=State/L=City/O=Org/CN=localhost" \
            -days 2
          # برای سادگی، همان server.crt نقش CA را هم ایفا می‌کند (self-signed)

      - name: Install project (CI extras)
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip setuptools wheel
          pip install -e .[ci]

      - name: Verify CI deps import
        run: |
          python -c "import sys; print('Python', sys.version)"
          python -c "import redis; print('redis', redis.__version__)"
          python -c "import prometheus_client, tenacity, yaml, jinja2; print('deps ok')"

      # --- Start Redis (plain, 6379) ---
      - name: Start Redis (plain)
        run: |
          set -euo pipefail
          docker run -d --name redis \
            -p 6379:6379 \
            redis:7 \
            redis-server --save "" --appendonly no
          # Wait until ready
          for i in {1..30}; do
            if docker exec redis redis-cli ping >/dev/null 2>&1; then
              echo "redis (6379) ready"; break
            fi
            sleep 1
          done

      # --- Start Redis (TLS, 6380) using official image + TLS flags ---
      - name: Start Redis (TLS)
        run: |
          set -euo pipefail
          docker run -d --name redistls \
            -p 6380:6380 \
            -v /tmp/certs:/certs:ro \
            redis:7 \
            redis-server --port 0 --tls-port 6380 \
              --tls-cert-file /certs/server.crt \
              --tls-key-file  /certs/server.key \
              --tls-ca-cert-file /certs/server.crt \
              --save "" --appendonly no
          # Health check with CA (not insecure), preserves CA validation
          for i in {1..45}; do
            if docker exec redistls redis-cli --tls --cacert /certs/server.crt -p 6380 ping >/dev/null 2>&1; then
              echo "redistls (6380 TLS) ready"; break
            fi
            sleep 1
          done

      # --- Pre-test cleanup (state hygiene) ---
      - name: Pre-test cleanup (flush both)
        run: |
          python - <<'PY'
          import os, ssl, sys
          import redis
          def flush(url, ca=None, allow_insecure=False):
              if not url:
                  return
              kw = {}
              if url.startswith("rediss://"):
                  kw["ssl"] = True
                  if allow_insecure:
                      ctx = ssl.create_default_context()
                      ctx.check_hostname = False
                      ctx.verify_mode = ssl.CERT_NONE
                      kw["ssl_context"] = ctx
                  elif ca:
                      kw["ssl_ca_certs"] = ca
              r = redis.Redis.from_url(url, **kw)
              try:
                  r.ping()
              except Exception as e:
                  print(f"[warn] ping failed for {url}: {e}", file=sys.stderr)
              try:
                  r.flushall()
                  print(f"[ok] FLUSHALL on {url}")
              except Exception as e:
                  print(f"[warn] flush failed for {url}: {e}", file=sys.stderr)
          flush(os.getenv("REDIS_URL"))
          flush(
              os.getenv("REDISS_URL"),
              ca=os.getenv("REDIS_TLS_CA_FILE"),
              allow_insecure=os.getenv("REDIS_TLS_ALLOW_INSECURE")=="1",
          )
          PY

      # --- Run tests (no warnings, no skips/xfails) ---
      - name: Run CI tests (no skips/xfails)
        run: |
          pytest -q -p pytest_asyncio -W error tests/ci

      # --- Post-test cleanup and teardown ---
      - name: Post-test cleanup (flush)
        if: always()
        run: |
          python - <<'PY'
          import os, ssl
          try:
              import redis
          except Exception as e:
              print(f"[warn] redis not importable in post-cleanup: {e}")
              raise SystemExit(0)
          def flush(url, ca=None):
              if not url:
                  return
              kw = {}
              if url.startswith("rediss://"):
                  kw["ssl"] = True
                  if ca:
                      kw["ssl_ca_certs"] = ca
              try:
                  redis.Redis.from_url(url, **kw).flushall()
                  print(f"[ok] POST FLUSHALL on {url}")
              except Exception as e:
                  print(f"[warn] post flush failed for {url}: {e}")
          flush(os.getenv("REDIS_URL"))
          flush(os.getenv("REDISS_URL"), os.getenv("REDIS_TLS_CA_FILE"))
          PY

      - name: Teardown containers (always)
        if: always()
        run: |
          docker logs redis || true
          docker logs redistls || true
          docker rm -f redis redistls || true
